fn get_input() -> [i32; 678] {
    return [
        3, 225, 1, 225, 6, 6, 1100, 1, 238, 225, 104, 0, 1101, 11, 91, 225, 1002, 121, 77, 224,
        101, -6314, 224, 224, 4, 224, 1002, 223, 8, 223, 1001, 224, 3, 224, 1, 223, 224, 223, 1102,
        74, 62, 225, 1102, 82, 7, 224, 1001, 224, -574, 224, 4, 224, 102, 8, 223, 223, 1001, 224,
        3, 224, 1, 224, 223, 223, 1101, 28, 67, 225, 1102, 42, 15, 225, 2, 196, 96, 224, 101,
        -4446, 224, 224, 4, 224, 102, 8, 223, 223, 101, 6, 224, 224, 1, 223, 224, 223, 1101, 86,
        57, 225, 1, 148, 69, 224, 1001, 224, -77, 224, 4, 224, 102, 8, 223, 223, 1001, 224, 2, 224,
        1, 223, 224, 223, 1101, 82, 83, 225, 101, 87, 14, 224, 1001, 224, -178, 224, 4, 224, 1002,
        223, 8, 223, 101, 7, 224, 224, 1, 223, 224, 223, 1101, 38, 35, 225, 102, 31, 65, 224, 1001,
        224, -868, 224, 4, 224, 1002, 223, 8, 223, 1001, 224, 5, 224, 1, 223, 224, 223, 1101, 57,
        27, 224, 1001, 224, -84, 224, 4, 224, 102, 8, 223, 223, 1001, 224, 7, 224, 1, 223, 224,
        223, 1101, 61, 78, 225, 1001, 40, 27, 224, 101, -89, 224, 224, 4, 224, 1002, 223, 8, 223,
        1001, 224, 1, 224, 1, 224, 223, 223, 4, 223, 99, 0, 0, 0, 677, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 1105, 0, 99999, 1105, 227, 247, 1105, 1, 99999, 1005, 227, 99999, 1005, 0, 256, 1105,
        1, 99999, 1106, 227, 99999, 1106, 0, 265, 1105, 1, 99999, 1006, 0, 99999, 1006, 227, 274,
        1105, 1, 99999, 1105, 1, 280, 1105, 1, 99999, 1, 225, 225, 225, 1101, 294, 0, 0, 105, 1, 0,
        1105, 1, 99999, 1106, 0, 300, 1105, 1, 99999, 1, 225, 225, 225, 1101, 314, 0, 0, 106, 0, 0,
        1105, 1, 99999, 1008, 677, 226, 224, 1002, 223, 2, 223, 1006, 224, 329, 101, 1, 223, 223,
        8, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 344, 101, 1, 223, 223, 1107, 226, 677, 224,
        102, 2, 223, 223, 1006, 224, 359, 101, 1, 223, 223, 1007, 226, 226, 224, 102, 2, 223, 223,
        1006, 224, 374, 101, 1, 223, 223, 7, 677, 677, 224, 102, 2, 223, 223, 1005, 224, 389, 1001,
        223, 1, 223, 108, 677, 677, 224, 1002, 223, 2, 223, 1005, 224, 404, 101, 1, 223, 223, 1008,
        226, 226, 224, 102, 2, 223, 223, 1005, 224, 419, 1001, 223, 1, 223, 1107, 677, 226, 224,
        102, 2, 223, 223, 1005, 224, 434, 1001, 223, 1, 223, 1108, 677, 677, 224, 102, 2, 223, 223,
        1006, 224, 449, 1001, 223, 1, 223, 7, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 464, 101,
        1, 223, 223, 1008, 677, 677, 224, 102, 2, 223, 223, 1005, 224, 479, 101, 1, 223, 223, 1007,
        226, 677, 224, 1002, 223, 2, 223, 1006, 224, 494, 101, 1, 223, 223, 8, 677, 226, 224, 1002,
        223, 2, 223, 1005, 224, 509, 101, 1, 223, 223, 1007, 677, 677, 224, 1002, 223, 2, 223,
        1006, 224, 524, 101, 1, 223, 223, 107, 226, 226, 224, 102, 2, 223, 223, 1006, 224, 539,
        101, 1, 223, 223, 107, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 554, 1001, 223, 1, 223,
        7, 677, 226, 224, 102, 2, 223, 223, 1006, 224, 569, 1001, 223, 1, 223, 107, 677, 677, 224,
        1002, 223, 2, 223, 1005, 224, 584, 101, 1, 223, 223, 1107, 677, 677, 224, 102, 2, 223, 223,
        1005, 224, 599, 101, 1, 223, 223, 1108, 226, 677, 224, 102, 2, 223, 223, 1006, 224, 614,
        101, 1, 223, 223, 8, 226, 226, 224, 102, 2, 223, 223, 1006, 224, 629, 101, 1, 223, 223,
        108, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 644, 1001, 223, 1, 223, 108, 226, 226,
        224, 102, 2, 223, 223, 1005, 224, 659, 101, 1, 223, 223, 1108, 677, 226, 224, 102, 2, 223,
        223, 1006, 224, 674, 1001, 223, 1, 223, 4, 223, 99, 226,
    ];
}

const POSITION_MODE: i32 = 0;
// const IMMEDIATE_MODE: i32 = 1;

fn extract_instructions(opcode: i32) -> (i32, i32, i32, i32) {
    let instruction = opcode % 100;
    let param0 = (opcode / 100) % 10;
    let param1 = (opcode / 1000) % 10;
    let param2 = (opcode / 10000) % 10;
    (instruction, param0, param1, param2)
}

fn extract_params(input: &[i32], param_mode: i32, index: usize) -> i32 {
    if param_mode == POSITION_MODE {
        input[input[index] as usize]
    } else {
        input[index]
    }
}

// const INPUT_PART1:i32 = 1;
const INPUT_PART2: i32 = 5;

pub fn first() {
    let mut input = get_input();
    // input[1] = 12;
    // input[2] = 2;
    let mut index = 0;
    while index < input.len() {
        println!("index {}", index);
        if input[index] == 99 {
            break;
        }

        let opcode = input[index];
        let (instruction, param0, param1, param2) = extract_instructions(opcode);
        println!(
            "opcode {}, instruction {}, p0 {}, p1 {}, p2 {}",
            opcode, instruction, param0, param1, param2,
        );
        assert!(param2 == 0);
        let mut instruction_move = 4;
        let mut jump = -1;
        if instruction == 1 {
            // add
            let lhs = extract_params(&input, param0, index + 1);
            let rhs = extract_params(&input, param1, index + 2);
            let target = input[index + 3] as usize;
            input[target] = lhs + rhs;
        } else if instruction == 2 {
            // multiply
            let lhs = extract_params(&input, param0, index + 1);
            let rhs = extract_params(&input, param1, index + 2);
            let target = input[index + 3] as usize;
            input[target] = lhs * rhs;
        } else if instruction == 3 {
            // input
            let target = input[index + 1] as usize;
            let input_value = INPUT_PART2;
            input[target] = input_value;
            instruction_move = 2;
            println!("Wrote {} to address {}", input_value, target);
        } else if instruction == 4 {
            // output
            let target = input[index + 1] as usize;
            println!("### Output is {}", input[target]);
            instruction_move = 2;
        } else if instruction == 5 {
            let condition = extract_params(&input, param0, index + 1) != 0;
            let address = extract_params(&input, param1, index + 2);
            println!("Jump {} to {}", condition, address);
            if condition {
                jump = address;
            } else {
                instruction_move = 3;
            }
        } else if instruction == 6 {
            let condition = extract_params(&input, param0, index + 1) == 0;
            let address = extract_params(&input, param1, index + 2);
            println!("Jump {} to {}", condition, address);
            if condition {
                jump = address;
            } else {
                instruction_move = 3;
            }
        } else if instruction == 7 {
            let lhs = extract_params(&input, param0, index + 1);
            let rhs = extract_params(&input, param1, index + 2);
            let target = input[index + 3] as usize;
            if lhs < rhs {
                input[target] = 1;
            } else {
                input[target] = 0;
            }
        } else if instruction == 8 {
            let lhs = extract_params(&input, param0, index + 1);
            let rhs = extract_params(&input, param1, index + 2);
            let target = input[index + 3] as usize;
            if lhs == rhs {
                input[target] = 1;
            } else {
                input[target] = 0;
            }
        }

        if jump >= 0 {
            index = jump as usize;
        } else {
            index += instruction_move;
        }
    }
    // println!("position 0: {}", input[0]);
}
